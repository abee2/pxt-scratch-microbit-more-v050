{"MbitMoreService.cpp":"/**\n  * Class definition for the Scratch MicroBit More Service.\n  * Provides a BLE service to remotely controll Micro:bit from Scratch3.\n  */\n#include \"MbitMoreService.h\"\n\nint gpio[] = {0, 1, 2, 8, 13, 14, 15, 16};\nint analogIn[] = {0, 1, 2};\nint digitalIn[] = {0, 1, 2}; // PullUp at connected to be same behaviour as the standard extension.\n\n/**\n * Get voltage of the power supply [mV].\n */\nint getPowerVoltage(void)\n{\n  // configuration\n  NRF_ADC->ENABLE = ADC_ENABLE_ENABLE_Enabled;\n  NRF_ADC->CONFIG = (ADC_CONFIG_RES_10bit << ADC_CONFIG_RES_Pos) |\n                    (ADC_CONFIG_INPSEL_SupplyOneThirdPrescaling << ADC_CONFIG_INPSEL_Pos) |\n                    (ADC_CONFIG_REFSEL_VBG << ADC_CONFIG_REFSEL_Pos) |\n                    (ADC_CONFIG_PSEL_Disabled << ADC_CONFIG_PSEL_Pos) |\n                    (ADC_CONFIG_EXTREFSEL_None << ADC_CONFIG_EXTREFSEL_Pos);\n\n  // read analog value from power supply\n  NRF_ADC->CONFIG &= ~ADC_CONFIG_PSEL_Msk;\n  NRF_ADC->CONFIG |= ADC_CONFIG_PSEL_Disabled << ADC_CONFIG_PSEL_Pos;\n  NRF_ADC->TASKS_START = 1;\n  while (((NRF_ADC->BUSY & ADC_BUSY_BUSY_Msk) >> ADC_BUSY_BUSY_Pos) == ADC_BUSY_BUSY_Busy)\n  {\n  };\n  return (int)(((float)NRF_ADC->RESULT * 3600.0f) / 1023.0f);\n}\n\n/**\n  * Constructor.\n  * Create a representation of the MbitMoreService\n  * @param _uBit The instance of a MicroBit runtime.\n  */\nMbitMoreService::MbitMoreService(MicroBit &_uBit)\n    : uBit(_uBit)\n{\n  // Calibrate the compass before start bluetooth service.\n  if (!uBit.compass.isCalibrated())\n  {\n    uBit.compass.calibrate();\n  }\n\n  // Create the data structures that represent each of our characteristics in Soft Device.\n  GattCharacteristic txCharacteristic(\n      MBIT_MORE_BASIC_TX,\n      (uint8_t *)&txData,\n      0,\n      sizeof(txData),\n      GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_READ | GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_NOTIFY);\n\n  GattCharacteristic rxCharacteristic(\n      MBIT_MORE_BASIC_RX,\n      (uint8_t *)&rxBuffer,\n      0,\n      sizeof(rxBuffer),\n      GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_WRITE | GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_WRITE_WITHOUT_RESPONSE);\n\n  // Set default security requirements\n  txCharacteristic.requireSecurity(SecurityManager::MICROBIT_BLE_SECURITY_LEVEL);\n  rxCharacteristic.requireSecurity(SecurityManager::MICROBIT_BLE_SECURITY_LEVEL);\n\n  GattCharacteristic *characteristics[] = {&txCharacteristic, &rxCharacteristic};\n  GattService service(\n      MBIT_MORE_BASIC_SERVICE, characteristics,\n      sizeof(characteristics) / sizeof(GattCharacteristic *));\n\n  uBit.ble->addService(service);\n\n  txCharacteristicHandle = txCharacteristic.getValueHandle();\n  rxCharacteristicHandle = rxCharacteristic.getValueHandle();\n\n  uBit.ble->gattServer().write(\n      txCharacteristicHandle,\n      (uint8_t *)&txData,\n      sizeof(txData));\n\n  // Advertise this service.\n  const uint16_t uuid16_list[] = {MBIT_MORE_BASIC_SERVICE};\n  uBit.ble->gap().accumulateAdvertisingPayload(GapAdvertisingData::INCOMPLETE_LIST_16BIT_SERVICE_IDS, (uint8_t *)uuid16_list, sizeof(uuid16_list));\n\n  // Mbit More Service\n  // Create the data structures that represent each of our characteristics in Soft Device.\n\n  eventChar = new GattCharacteristic(\n      MBIT_MORE_EVENT,\n      (uint8_t *)&eventBuffer,\n      0,\n      sizeof(eventBuffer),\n      GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_READ | GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_NOTIFY);\n  ioChar = new GattCharacteristic(\n      MBIT_MORE_IO,\n      (uint8_t *)&ioBuffer,\n      0,\n      sizeof(ioBuffer),\n      GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_READ);\n  analogInChar = new GattCharacteristic(\n      MBIT_MORE_ANALOG_IN,\n      (uint8_t *)&analogInBuffer,\n      0,\n      sizeof(analogInBuffer),\n      GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_READ);\n  analogInChar->setReadAuthorizationCallback(this, &MbitMoreService::onReadAnalogIn);\n  sensorsChar = new GattCharacteristic(\n      MBIT_MORE_SENSORS,\n      (uint8_t *)&sensorsBuffer,\n      0,\n      sizeof(sensorsBuffer),\n      GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_READ);\n  sharedDataChar = new GattCharacteristic(\n      MBIT_MORE_SHARED_DATA,\n      (uint8_t *)&sharedBuffer,\n      0,\n      sizeof(sharedBuffer),\n      GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_READ | GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_NOTIFY | GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_WRITE | GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_WRITE_WITHOUT_RESPONSE);\n\n  // Set default security requirements\n  analogInChar->requireSecurity(SecurityManager::MICROBIT_BLE_SECURITY_LEVEL);\n  eventChar->requireSecurity(SecurityManager::MICROBIT_BLE_SECURITY_LEVEL);\n  ioChar->requireSecurity(SecurityManager::MICROBIT_BLE_SECURITY_LEVEL);\n  sensorsChar->requireSecurity(SecurityManager::MICROBIT_BLE_SECURITY_LEVEL);\n  sharedDataChar->requireSecurity(SecurityManager::MICROBIT_BLE_SECURITY_LEVEL);\n\n  GattCharacteristic *mbitMoreChars[] = {\n      eventChar,\n      ioChar,\n      analogInChar,\n      sensorsChar,\n      sharedDataChar};\n  GattService mbitMoreService(\n      MBIT_MORE_SERVICE, mbitMoreChars,\n      sizeof(mbitMoreChars) / sizeof(GattCharacteristic *));\n\n  uBit.ble->addService(mbitMoreService);\n\n  eventCharHandle = eventChar->getValueHandle();\n  ioCharHandle = ioChar->getValueHandle();\n  sensorsCharHandle = sensorsChar->getValueHandle();\n  sharedDataCharHandle = sharedDataChar->getValueHandle();\n\n  // Initialize buffers.\n  sharedBuffer[DATA_FORMAT_INDEX] = MBitMoreDataFormat::SHARED_DATA;\n  eventBuffer[DATA_FORMAT_INDEX] = MBitMoreDataFormat::EVENT;\n\n  // Advertise this service.\n  const uint8_t *mbitMoreServices[] = {MBIT_MORE_SERVICE};\n  uBit.ble->gap().accumulateAdvertisingPayload(GapAdvertisingData::COMPLETE_LIST_128BIT_SERVICE_IDS, (uint8_t *)mbitMoreServices, sizeof(mbitMoreServices));\n\n  // Setup callbacks for events.\n  uBit.ble->onDataWritten(this, &MbitMoreService::onDataWritten);\n\n  uBit.messageBus.listen(MICROBIT_ID_BLE, MICROBIT_BLE_EVT_CONNECTED, this, &MbitMoreService::onBLEConnected, MESSAGE_BUS_LISTENER_IMMEDIATE);\n  uBit.messageBus.listen(MICROBIT_ID_BLE, MICROBIT_BLE_EVT_DISCONNECTED, this, &MbitMoreService::onBLEDisconnected, MESSAGE_BUS_LISTENER_IMMEDIATE);\n\n  uBit.messageBus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_EVT_ANY, this, &MbitMoreService::onButtonChanged, MESSAGE_BUS_LISTENER_IMMEDIATE);\n  uBit.messageBus.listen(MICROBIT_ID_BUTTON_B, MICROBIT_EVT_ANY, this, &MbitMoreService::onButtonChanged, MESSAGE_BUS_LISTENER_IMMEDIATE);\n  uBit.messageBus.listen(MICROBIT_ID_GESTURE, MICROBIT_EVT_ANY, this, &MbitMoreService::onGestureChanged, MESSAGE_BUS_LISTENER_IMMEDIATE);\n}\n\nvoid MbitMoreService::initConfiguration()\n{\n  // Initialize pin configuration.\n  for (size_t i = 0; i < sizeof(digitalIn) / sizeof(digitalIn[0]); i++)\n  {\n    setPullMode(digitalIn[i], PinMode::PullUp);\n  }\n\n  // Initialize microbit more protocol.\n  mbitMoreProtocol = 0;\n}\n\n/**\n  * Callback. Invoked when AnalogIn is read via BLE.\n  */\nvoid MbitMoreService::onReadAnalogIn(GattReadAuthCallbackParams *authParams)\n{\n  updateAnalogValues();\n  // analog value (0 to 1023) is sent as uint16_t little-endian.\n  memcpy(&(analogInBuffer[0]), &(analogValues[0]), 2);\n  memcpy(&(analogInBuffer[2]), &(analogValues[1]), 2);\n  memcpy(&(analogInBuffer[4]), &(analogValues[2]), 2);\n  // voltage of power supply [mV] is sent as uint16_t little-endian.\n  memcpy(&(analogInBuffer[6]), &powerVoltage, 2);\n  authParams->data = (uint8_t *)&analogInBuffer;\n  authParams->offset = 0;\n  authParams->len = sizeof(analogInBuffer) / sizeof(analogInBuffer[0]);\n  authParams->authorizationReply = AUTH_CALLBACK_REPLY_SUCCESS;\n}\n\n/**\n  * Callback. Invoked when any of our attributes are written via BLE.\n  */\nvoid MbitMoreService::onDataWritten(const GattWriteCallbackParams *params)\n{\n  uint8_t *data = (uint8_t *)params->data;\n\n  if (params->handle == rxCharacteristicHandle && params->len > 0)\n  {\n    if (data[0] == ScratchBLECommand::CMD_DISPLAY_TEXT)\n    {\n      char text[params->len];\n      memcpy(text, &(data[1]), (params->len) - 1);\n      text[(params->len) - 1] = '\\0';\n      ManagedString mstr(text);\n      uBit.display.stopAnimation();        // Do not wait the end of current animation as same as the standard extension.\n      uBit.display.scrollAsync(mstr, 120); // Interval is corresponding with the standard extension.\n    }\n    else if (data[0] == ScratchBLECommand::CMD_DISPLAY_LED)\n    {\n      uBit.display.stopAnimation();\n      for (int y = 1; y < params->len; y++)\n      {\n        for (int x = 0; x < 5; x++)\n        {\n          uBit.display.image.setPixelValue(x, y - 1, (data[y] & (0x01 << x)) ? 255 : 0);\n        }\n      }\n    }\n    else if (data[0] == ScratchBLECommand::CMD_PIN)\n    {\n      if (data[1] == MBitMorePinCommand::SET_PULL)\n      {\n        switch (data[3])\n        {\n        case MBitMorePinMode::PullNone:\n          setPullMode(data[2], PinMode::PullNone);\n          break;\n        case MBitMorePinMode::PullUp:\n          setPullMode(data[2], PinMode::PullUp);\n          break;\n        case MBitMorePinMode::PullDown:\n          setPullMode(data[2], PinMode::PullDown);\n          break;\n\n        default:\n          break;\n        }\n      }\n      else if (data[1] == MBitMorePinCommand::SET_TOUCH)\n      {\n        setPinModeTouch(data[2]);\n      }\n      else if (data[1] == MBitMorePinCommand::SET_OUTPUT)\n      {\n        setDigitalValue(data[2], data[3]);\n      }\n      else if (data[1] == MBitMorePinCommand::SET_PWM)\n      {\n        // value is read as uint16_t little-endian.\n        int value;\n        memcpy(&value, &(data[3]), 2);\n        setAnalogValue(data[2], value);\n      }\n      else if (data[1] == MBitMorePinCommand::SET_SERVO)\n      {\n        int pinIndex = (int)data[2];\n        // angle is read as uint16_t little-endian.\n        uint16_t angle;\n        memcpy(&angle, &(data[3]), 2);\n        // range is read as uint16_t little-endian.\n        uint16_t range;\n        memcpy(&range, &(data[5]), 2);\n        // center is read as uint16_t little-endian.\n        uint16_t center;\n        memcpy(&center, &(data[7]), 2);\n        if (range == 0)\n        {\n          uBit.io.pin[pinIndex].setServoValue(angle);\n        }\n        else if (center == 0)\n        {\n          uBit.io.pin[pinIndex].setServoValue(angle, range);\n        }\n        else\n        {\n          uBit.io.pin[pinIndex].setServoValue(angle, range, center);\n        }\n      }\n      else if (data[1] == MBitMorePinCommand::SET_EVENT)\n      {\n        listenPinEventOn((int)data[2], (int)data[3]);\n      }\n    }\n    else if (data[0] == ScratchBLECommand::CMD_SHARED_DATA)\n    {\n      // value is read as int16_t little-endian.\n      int16_t value;\n      memcpy(&value, &(data[2]), 2);\n      sharedData[data[1]] = value;\n    }\n    else if (data[0] == ScratchBLECommand::CMD_PROTOCOL)\n    {\n      mbitMoreProtocol = data[1];\n    }\n    else if (data[0] == ScratchBLECommand::CMD_LIGHT_SENSING)\n    {\n      setLightSensingDuration(data[1]);\n    }\n  }\n}\n\n/**\n * Make it listen events of the event type on the pin.\n * Remove listener if the event type is MICROBIT_PIN_EVENT_NONE.\n */\nvoid MbitMoreService::listenPinEventOn(int pinIndex, int eventType)\n{\n  int componentID;  // ID of the MicroBit Component that generated the event.\n  switch (pinIndex) // Index of pin to set event.\n  {\n  case 0:\n    componentID = MICROBIT_ID_IO_P0;\n    break;\n  case 1:\n    componentID = MICROBIT_ID_IO_P1;\n    break;\n  case 2:\n    componentID = MICROBIT_ID_IO_P2;\n    break;\n  case 8:\n    componentID = MICROBIT_ID_IO_P8;\n    break;\n  case 13:\n    componentID = MICROBIT_ID_IO_P13;\n    break;\n  case 14:\n    componentID = MICROBIT_ID_IO_P14;\n    break;\n  case 15:\n    componentID = MICROBIT_ID_IO_P15;\n    break;\n  case 16:\n    componentID = MICROBIT_ID_IO_P16;\n    break;\n\n  default:\n    return;\n  }\n  if (eventType == MBitMorePinEventType::NONE)\n  {\n    uBit.messageBus.ignore(componentID, MICROBIT_EVT_ANY, this, &MbitMoreService::onPinEvent);\n    uBit.io.pin[pinIndex].eventOn(MICROBIT_PIN_EVENT_NONE);\n  }\n  else\n  {\n    uBit.messageBus.listen(componentID, MICROBIT_EVT_ANY, this, &MbitMoreService::onPinEvent, MESSAGE_BUS_LISTENER_DROP_IF_BUSY);\n    if (eventType == MBitMorePinEventType::ON_EDGE)\n    {\n      uBit.io.pin[pinIndex].eventOn(MICROBIT_PIN_EVENT_ON_EDGE);\n    }\n    else if (eventType == MBitMorePinEventType::ON_PULSE)\n    {\n      uBit.io.pin[pinIndex].eventOn(MICROBIT_PIN_EVENT_ON_PULSE);\n    }\n    else if (eventType == MBitMorePinEventType::ON_TOUCH)\n    {\n      uBit.io.pin[pinIndex].eventOn(MICROBIT_PIN_EVENT_ON_TOUCH);\n    }\n  }\n}\n\n/**\n * Callback. Invoked when a pin event sent.\n */\nvoid MbitMoreService::onPinEvent(MicroBitEvent evt)\n{\n  uint8_t pinIndex;\n  switch (evt.source) // ID of the MicroBit Component that generated the event. (uint16_t)\n  {\n  case MICROBIT_ID_IO_P0:\n    eventBuffer[0] = 0;\n    break;\n  case MICROBIT_ID_IO_P1:\n    eventBuffer[0] = 1;\n    break;\n  case MICROBIT_ID_IO_P2:\n    eventBuffer[0] = 2;\n    break;\n  case MICROBIT_ID_IO_P8:\n    eventBuffer[0] = 8;\n    break;\n  case MICROBIT_ID_IO_P13:\n    eventBuffer[0] = 13;\n    break;\n  case MICROBIT_ID_IO_P14:\n    eventBuffer[0] = 14;\n    break;\n  case MICROBIT_ID_IO_P15:\n    eventBuffer[0] = 15;\n    break;\n  case MICROBIT_ID_IO_P16:\n    eventBuffer[0] = 16;\n    break;\n\n  default:\n    break;\n  }\n\n  // event ID is sent as uint16_t little-endian.\n  // #define MICROBIT_PIN_EVT_RISE               2\n  // #define MICROBIT_PIN_EVT_FALL               3\n  // #define MICROBIT_PIN_EVT_PULSE_HI           4\n  // #define MICROBIT_PIN_EVT_PULSE_LO           5\n  memcpy(&(eventBuffer[1]), &(evt.value), 2);\n\n  // event timestamp is sent as uint32_t little-endian coerced from uint64_t value.\n  uint32_t timestamp = (uint32_t)evt.timestamp;\n  memcpy(&(eventBuffer[3]), &timestamp, 4);\n\n  uBit.ble->gattServer().notify(\n      eventCharHandle,\n      (uint8_t *)&eventBuffer,\n      sizeof(eventBuffer) / sizeof(eventBuffer[0]));\n}\n\n/**\n  * Button update callback\n  */\nvoid MbitMoreService::onButtonChanged(MicroBitEvent e)\n{\n  int state;\n  if (e.value == MICROBIT_BUTTON_EVT_UP)\n  {\n    state = 0;\n  }\n  if (e.value == MICROBIT_BUTTON_EVT_DOWN)\n  {\n    state = 1;\n  }\n  if (e.value == MICROBIT_BUTTON_EVT_HOLD)\n  {\n    state = 5;\n  }\n  // if (e.value == MICROBIT_BUTTON_EVT_CLICK)\n  // {\n  //   state = 3;\n  // }\n  // if (e.value == MICROBIT_BUTTON_EVT_LONG_CLICK)\n  // {\n  //   state = 4;\n  // }\n  // if (e.value == MICROBIT_BUTTON_EVT_DOUBLE_CLICK)\n  // {\n  //   state = 6;\n  // }\n  if (e.source == MICROBIT_ID_BUTTON_A)\n  {\n    buttonAState = state;\n  }\n  if (e.source == MICROBIT_ID_BUTTON_B)\n  {\n    buttonBState = state;\n  }\n}\n\nvoid MbitMoreService::onGestureChanged(MicroBitEvent e)\n{\n  if (e.value == MICROBIT_ACCELEROMETER_EVT_SHAKE)\n  {\n    gesture = gesture | 1;\n  }\n  if (e.value == MICROBIT_ACCELEROMETER_EVT_FREEFALL)\n  {\n    gesture = gesture | 1 << 1;\n  }\n}\n\n/**\n * Normalize angle in upside down.\n */\nint MbitMoreService::normalizeCompassHeading(int heading)\n{\n  if (uBit.accelerometer.getZ() > 0)\n  {\n    if (heading <= 180)\n    {\n      heading = 180 - heading;\n    }\n    else\n    {\n      heading = 360 - (heading - 180);\n    }\n  }\n  return heading;\n}\n\n/**\n * Convert roll/pitch radians to Scratch extension value (-1000 to 1000).\n */\nint MbitMoreService::convertToTilt(float radians)\n{\n  float degrees = (360.0f * radians) / (2.0f * PI);\n  float tilt = degrees * 1.0f / 90.0f;\n  if (degrees > 0)\n  {\n    if (tilt > 1.0f)\n      tilt = 2.0f - tilt;\n  }\n  else\n  {\n    if (tilt < -1.0f)\n      tilt = -2.0f - tilt;\n  }\n  return (int)(tilt * 1000.0f);\n}\n\nvoid MbitMoreService::updateGesture()\n{\n  int old[] = {lastAcc[0], lastAcc[1], lastAcc[2]};\n  lastAcc[0] = uBit.accelerometer.getX();\n  lastAcc[1] = uBit.accelerometer.getY();\n  lastAcc[2] = uBit.accelerometer.getZ();\n  if ((gesture >> 2) & 1)\n  {\n    gesture = gesture ^ (1 << 2);\n    return;\n  }\n  int threshold = 50;\n  if ((abs(lastAcc[0] - old[0]) > threshold) || (abs(lastAcc[1] - old[1]) > threshold) || (abs(lastAcc[2] - old[2]) > threshold))\n  {\n    // Moved\n    gesture = gesture | (1 << 2);\n  }\n}\n\nvoid MbitMoreService::resetGesture()\n{\n  gesture = gesture & (1 << 2); // Save moved state to detect continuous movement.\n}\n\nvoid MbitMoreService::updateDigitalValues()\n{\n  digitalValues = 0;\n  for (size_t i = 0; i < sizeof(gpio) / sizeof(gpio[0]); i++)\n  {\n    if (uBit.io.pin[gpio[i]].isDigital())\n    {\n      if (uBit.io.pin[gpio[i]].isInput())\n      {\n        digitalValues =\n            digitalValues | (uBit.io.pin[gpio[i]].getDigitalValue() << gpio[i]);\n      }\n    }\n  }\n}\n\nvoid MbitMoreService::updatePowerVoltage()\n{\n  powerVoltage = getPowerVoltage();\n}\n\nvoid MbitMoreService::updateAnalogValues()\n{\n  for (size_t i = 0; i < sizeof(analogIn) / sizeof(analogIn[0]); i++)\n  {\n    updatePowerVoltage();\n    int samplingCount;\n    int prevValue;\n    int value;\n    if (uBit.io.pin[analogIn[i]].isInput())\n    {\n      uBit.io.pin[analogIn[i]].setPull(PinMode::PullNone);\n      // for accuracy, read more than 2 times to get same values continuously\n      do\n      {\n        prevValue = value;\n        value = (uint16_t)uBit.io.pin[analogIn[i]].getAnalogValue();\n        samplingCount++;\n      } while (prevValue != value || samplingCount < 4);\n      analogValues[i] = value;\n      setPullMode(analogIn[i], pullMode[analogIn[i]]);\n    }\n  }\n\n  //// It will cause flickering LED.\n  // uBit.display.disable();\n  // analogValues[3] = (uint16_t)uBit.io.P3.getAnalogValue();\n  // analogValues[4] = (uint16_t)uBit.io.P4.getAnalogValue();\n  // analogValues[5] = (uint16_t)uBit.io.P10.getAnalogValue();\n  // uBit.display.enable();\n}\n\nvoid MbitMoreService::updateLightSensor()\n{\n  if (lightSensingDuration <= 0)\n  {\n    uBit.display.setDisplayMode(DisplayMode::DISPLAY_MODE_BLACK_AND_WHITE);\n    return;\n  }\n  lightLevel = uBit.display.readLightLevel();\n  if (lightSensingDuration < 255) // over 255 means no-limited.\n  {\n    lightSensingDuration--;\n  }\n}\n\nvoid MbitMoreService::updateAccelerometer()\n{\n  acceleration[0] = -uBit.accelerometer.getX(); // Face side is positive in Z-axis.\n  acceleration[1] = uBit.accelerometer.getY();\n  acceleration[2] = -uBit.accelerometer.getZ(); // Face side is positive in Z-axis.\n  rotation[0] = uBit.accelerometer.getPitchRadians();\n  rotation[1] = uBit.accelerometer.getRollRadians();\n}\n\nvoid MbitMoreService::updateMagnetometer()\n{\n  compassHeading = uBit.compass.heading();\n  magneticForce[0] = uBit.compass.getX();\n  magneticForce[1] = uBit.compass.getY();\n  magneticForce[2] = uBit.compass.getZ();\n}\n\nvoid MbitMoreService::setPullMode(int pinIndex, PinMode pull)\n{\n  uBit.io.pin[pinIndex].getDigitalValue(pull);\n  pullMode[pinIndex] = pull;\n}\n\nvoid MbitMoreService::setDigitalValue(int pinIndex, int value)\n{\n  uBit.io.pin[pinIndex].setDigitalValue(value);\n}\n\nvoid MbitMoreService::setAnalogValue(int pinIndex, int value)\n{\n  uBit.io.pin[pinIndex].setAnalogValue(value);\n}\n\nvoid MbitMoreService::setServoValue(int pinIndex, int angle, int range, int center)\n{\n  uBit.io.pin[pinIndex].setServoValue(angle, range, center);\n}\n\nvoid MbitMoreService::setPinModeTouch(int pinIndex)\n{\n  uBit.io.pin[pinIndex].isTouched(); // Configure to touch mode then the return value is not used.\n}\n\nvoid MbitMoreService::setLightSensingDuration(int duration)\n{\n  lightSensingDuration = duration;\n}\n\nvoid MbitMoreService::composeDefaultData(uint8_t *buff)\n{\n  // Tilt value is sent as int16_t big-endian.\n  int16_t tiltX = (int16_t)convertToTilt(rotation[1]);\n  buff[0] = (tiltX >> 8) & 0xFF;\n  buff[1] = tiltX & 0xFF;\n  int16_t tiltY = (int16_t)convertToTilt(rotation[0]);\n  buff[2] = (tiltY >> 8) & 0xFF;\n  buff[3] = tiltY & 0xFF;\n  buff[4] = (uint8_t)buttonAState;\n  buff[5] = (uint8_t)buttonBState;\n  buff[6] = (uint8_t)(((digitalValues >> 0) & 1) ^ 1);\n  buff[7] = (uint8_t)(((digitalValues >> 1) & 1) ^ 1);\n  buff[8] = (uint8_t)(((digitalValues >> 2) & 1) ^ 1);\n  buff[9] = (uint8_t)gesture;\n}\n\n/**\n  * Notify shared data to Scratch3\n  */\nvoid MbitMoreService::notifySharedData()\n{\n  for (size_t i = 0; i < sizeof(sharedData) / sizeof(sharedData[0]); i++)\n  {\n    memcpy(&(sharedBuffer[(i * 2)]), &sharedData[i], 2);\n  }\n  uBit.ble->gattServer().notify(\n      sharedDataCharHandle,\n      (uint8_t *)&sharedBuffer,\n      sizeof(sharedBuffer) / sizeof(sharedBuffer[0]));\n}\n\n/**\n * Notify default micro:bit data to Scratch.\n */\nvoid MbitMoreService::notifyDefaultData()\n{\n  composeDefaultData(txData);\n  uBit.ble->gattServer().notify(\n      txCharacteristicHandle,\n      (uint8_t *)&txData,\n      sizeof(txData) / sizeof(txData[0]));\n}\n\n/**\n  * Notify data to Scratch3\n  */\nvoid MbitMoreService::notify()\n{\n  if (uBit.ble->gap().getState().connected)\n  {\n    updateGesture();\n    notifyDefaultData();\n    resetGesture();\n  }\n  else\n  {\n    displayFriendlyName();\n  }\n}\n\n/**\n * Set value to shared data.\n * shared data (0, 1, 2, 3)\n */\nvoid MbitMoreService::setSharedData(int index, int value)\n{\n  // value (-32768 to 32767) is sent as int16_t little-endian.\n  int16_t data = (int16_t)value;\n  sharedData[index] = data;\n  notifySharedData();\n}\n\n/**\n * Get value of a shared data.\n * shared data (0, 1, 2, 3)\n */\nint MbitMoreService::getSharedData(int index)\n{\n  return (int)(sharedData[index]);\n}\n\nvoid MbitMoreService::onBLEConnected(MicroBitEvent _e)\n{\n  uBit.display.stopAnimation(); // To stop display friendly name.\n  initConfiguration();\n  uBit.display.scrollAsync(\"v.0.5.0\");\n  lightSensingDuration = 255; // Continuous light sensing for GUI v0.4.2\n}\n\nvoid MbitMoreService::onBLEDisconnected(MicroBitEvent _e)\n{\n  lightSensingDuration = 0;\n}\n\n/**\n * Update sensors.\n */\nvoid MbitMoreService::update()\n{\n  updateDigitalValues();\n  writeIo();\n  updateLightSensor();\n  updateAccelerometer();\n  updateMagnetometer();\n  writeSensors();\n}\n\n/**\n  * Write IO characteristics.\n  */\nvoid MbitMoreService::writeIo()\n{\n  memcpy(&(ioBuffer[0]), &digitalValues, 4);\n\n  uBit.ble->gattServer().write(\n      ioCharHandle,\n      (uint8_t *)&ioBuffer,\n      sizeof(ioBuffer) / sizeof(ioBuffer[0]));\n}\n\n/**\n  * Write shared data characteristics.\n  */\nvoid MbitMoreService::writeSharedData()\n{\n  for (size_t i = 0; i < sizeof(sharedData) / sizeof(sharedData[0]); i++)\n  {\n    memcpy(&(sharedBuffer[(i * 2)]), &sharedData[i], 2);\n  }\n\n  uBit.ble->gattServer().write(\n      sharedDataCharHandle,\n      (uint8_t *)&sharedBuffer,\n      sizeof(sharedBuffer) / sizeof(sharedBuffer[0]));\n}\n\n/**\n  * Write data of all sensors to the characteristic.\n  */\nvoid MbitMoreService::writeSensors()\n{\n  // Accelerometer\n  int16_t acc;\n  // Acceleration X [milli-g] is sent as int16_t little-endian.\n  acc = (int16_t)acceleration[0];\n  memcpy(&(sensorsBuffer[0]), &acc, 2);\n  // Acceleration Y [milli-g] is sent as int16_t little-endian.\n  acc = (int16_t)acceleration[1];\n  memcpy(&(sensorsBuffer[2]), &acc, 2);\n  // Acceleration Z [milli-g] is sent as int16_t little-endian.\n  acc = (int16_t)acceleration[2];\n  memcpy(&(sensorsBuffer[4]), &acc, 2);\n\n  int16_t rot;\n  // Pitch (radians / 1000) is sent as int16_t little-endian [6..7].\n  rot = (int16_t)(rotation[0] * 1000);\n  memcpy(&(sensorsBuffer[6]), &rot, 2);\n  // Roll (radians / 1000) is sent as int16_t little-endian [8..9].\n  rot = (int16_t)(rotation[1] * 1000);\n  memcpy(&(sensorsBuffer[8]), &rot, 2);\n\n  // Magnetometer\n  uint16_t heading = (uint16_t)normalizeCompassHeading(compassHeading);\n  memcpy(&(sensorsBuffer[10]), &heading, 2);\n\n  int16_t force;\n  // Magnetic force X (micro-teslas) is sent as uint16_t little-endian [2..3].\n  force = (int16_t)(magneticForce[0] / 1000);\n  memcpy(&(sensorsBuffer[12]), &force, 2);\n  // Magnetic force Y (micro-teslas) is sent as uint16_t little-endian [4..5].\n  force = (int16_t)(magneticForce[1] / 1000);\n  memcpy(&(sensorsBuffer[14]), &force, 2);\n  // Magnetic force Z (micro-teslas) is sent as uint16_t little-endian [6..7].\n  force = (int16_t)(magneticForce[2] / 1000);\n  memcpy(&(sensorsBuffer[16]), &force, 2);\n\n  // Light sensor\n  sensorsBuffer[18] = (uint8_t)lightLevel;\n\n  // Temperature\n  sensorsBuffer[19] = (uint8_t)(uBit.thermometer.getTemperature() + 128);\n\n  uBit.ble->gattServer().write(\n      sensorsCharHandle,\n      (uint8_t *)&sensorsBuffer,\n      sizeof(sensorsBuffer) / sizeof(sensorsBuffer[0]));\n}\n\nvoid MbitMoreService::displayFriendlyName()\n{\n  ManagedString suffix(\" MORE! \");\n  uBit.display.scrollAsync(uBit.getName() + suffix, 120);\n}\n\nconst uint16_t MBIT_MORE_BASIC_SERVICE = 0xf005;\nconst uint8_t MBIT_MORE_BASIC_TX[] = {0x52, 0x61, 0xda, 0x01, 0xfa, 0x7e, 0x42, 0xab, 0x85, 0x0b, 0x7c, 0x80, 0x22, 0x00, 0x97, 0xcc};\nconst uint8_t MBIT_MORE_BASIC_RX[] = {0x52, 0x61, 0xda, 0x02, 0xfa, 0x7e, 0x42, 0xab, 0x85, 0x0b, 0x7c, 0x80, 0x22, 0x00, 0x97, 0xcc};\n\nconst uint8_t MBIT_MORE_SERVICE[] = {0xa6, 0x2d, 0x57, 0x4e, 0x1b, 0x34, 0x40, 0x92, 0x8d, 0xee, 0x41, 0x51, 0xf6, 0x3b, 0x28, 0x65};\nconst uint8_t MBIT_MORE_EVENT[] = {0xa6, 0x2d, 0x00, 0x01, 0x1b, 0x34, 0x40, 0x92, 0x8d, 0xee, 0x41, 0x51, 0xf6, 0x3b, 0x28, 0x65};\nconst uint8_t MBIT_MORE_IO[] = {0xa6, 0x2d, 0x00, 0x02, 0x1b, 0x34, 0x40, 0x92, 0x8d, 0xee, 0x41, 0x51, 0xf6, 0x3b, 0x28, 0x65};\nconst uint8_t MBIT_MORE_ANALOG_IN[] = {0xa6, 0x2d, 0x00, 0x03, 0x1b, 0x34, 0x40, 0x92, 0x8d, 0xee, 0x41, 0x51, 0xf6, 0x3b, 0x28, 0x65};\nconst uint8_t MBIT_MORE_SENSORS[] = {0xa6, 0x2d, 0x00, 0x04, 0x1b, 0x34, 0x40, 0x92, 0x8d, 0xee, 0x41, 0x51, 0xf6, 0x3b, 0x28, 0x65};\nconst uint8_t MBIT_MORE_SHARED_DATA[] = {0xa6, 0x2d, 0x00, 0x10, 0x1b, 0x34, 0x40, 0x92, 0x8d, 0xee, 0x41, 0x51, 0xf6, 0x3b, 0x28, 0x65};\n","MbitMoreService.h":"#ifndef SCRATCH_MORE_SERVICE_H\n#define SCRATCH_MORE_SERVICE_H\n\n#include \"MicroBit.h\"\n\n#define SCRATCH_MORE_ID 2000\n\n#define SCRATCH_MORE_EVT_NOTIFY 1\n\n/**\n * Position of data format in a value holder.\n */\n#define DATA_FORMAT_INDEX 19\n\n// UUIDs for our service and characteristics\nextern const uint16_t MBIT_MORE_BASIC_SERVICE;\nextern const uint8_t MBIT_MORE_BASIC_TX[];\nextern const uint8_t MBIT_MORE_BASIC_RX[];\nextern const uint8_t MBIT_MORE_SERVICE[];\nextern const uint8_t MBIT_MORE_EVENT[];\nextern const uint8_t MBIT_MORE_IO[];\nextern const uint8_t MBIT_MORE_SENSORS[];\nextern const uint8_t MBIT_MORE_SHARED_DATA[];\nextern const uint8_t MBIT_MORE_ANALOG_IN[];\n\n/**\n  * Class definition for a MicroBitMore Service.\n  * Provides a BLE service to remotely read the state of sensors from Scratch3.\n  */\nclass MbitMoreService\n{\npublic:\n  /**\n    * Constructor.\n    * Create a representation of the MbitMoreService\n    * @param _uBit The instance of a MicroBit runtime.\n    */\n  MbitMoreService(MicroBit &_uBit);\n\n  void initConfiguration();\n\n  /**\n    * Notify data to Scratch3.\n    */\n  void notify();\n  void notifyDefaultData();\n  void notifySharedData();\n\n  /**\n   * Set value to Slots.\n   */\n  void setSharedData(int index, int value);\n\n  /**\n   * Get value to Slots.\n   */\n  int getSharedData(int index);\n\n  /**\n   * Callback. Invoked when AnalogIn is read via BLE.\n   */\n  void onReadAnalogIn(GattReadAuthCallbackParams *authParams);\n\n  /**\n   * Callback. Invoked when any of our attributes are written via BLE.\n   */\n  void onDataWritten(const GattWriteCallbackParams *params);\n\n  /**\n   * Invocked when the bluetooth connected.\n   */\n  void onBLEConnected(MicroBitEvent e);\n\n  /**\n   * Invocked when the bluetooth disconnected.\n   */\n  void onBLEDisconnected(MicroBitEvent e);\n\n  /**\n   * Callback. Invoked when a pin event sent.\n   */\n  void onPinEvent(MicroBitEvent evt);\n\n  void update();\n\n  void updateDigitalValues();\n  void updatePowerVoltage();\n  void updateAnalogValues();\n  void updateLightSensor();\n  void updateAccelerometer();\n  void updateMagnetometer();\n\n  void writeIo();\n  void writeAnalogIn();\n  void writeSensors();\n  void writeSharedData();\n\nprivate:\n\n  // Sending data to Scratch3.\n  uint8_t txData[20];\n\n  // Recieving buffer from Scratch3.\n  uint8_t rxBuffer[10];\n\n  // Config buffer set by Scratch.\n  uint8_t eventBuffer[20];\n\n  // Sending data of IO to Scratch.\n  uint8_t ioBuffer[4];\n\n  // Sending data of analog input to Scratch.\n  uint8_t analogInBuffer[20];\n\n  // Sending data of all sensors to Scratch.\n  uint8_t sensorsBuffer[20];\n\n  // Shared data with Scratch.\n  uint8_t sharedBuffer[20];\n\n  /**\n   * Button state.\n   */\n  int buttonAState;\n  int buttonBState;\n\n  /**\n   * Hold gesture state until next nofification.\n   */\n  int gesture;\n\n  /**\n   * Save the last accelerometer values to conpaire current for detecting moving.\n   */\n  int lastAcc[3];\n\n  /**\n   * Heading angle of compass.\n   */\n  int compassHeading;\n\n  uint32_t digitalValues;\n\n  uint16_t analogValues[6];\n\n  /**\n   * Light level value from 0 to 255.\n   */\n  int lightLevel;\n\n  int lightSensingDuration;\n\n  /**\n   * Acceleration value [x, y, z] in milli-g.\n   */\n  int acceleration[6];\n\n  /**\n   * Rotation value [pitch, roll] in radians.\n   */\n  float rotation[2];\n\n  /**\n   * Magnetic force [x, y, z] in 1000 * micro-teslas.\n   */\n  int magneticForce[3];\n\n  /**\n   * Shared data\n   */\n  int16_t sharedData[4];\n\n  /**\n   * Protocol of microbit more.\n   */\n  int mbitMoreProtocol;\n\n  /**\n   * Current mode of all pins.\n   */\n  PinMode pullMode[21];\n  \n  /**\n   * Voltage of the power supply in [mV]\n   */\n  int powerVoltage;\n\n\n  void listenPinEventOn(int pinIndex, int eventType);\n  void setPullMode(int pinIndex, PinMode pull);\n  void setDigitalValue(int pinIndex, int value);\n  void setAnalogValue(int pinIndex, int value);\n  void setServoValue(int pinIndex, int angle, int range, int center);\n  void setPinModeTouch(int pinIndex);\n  void setLightSensingDuration(int duration);\n\n  void onButtonChanged(MicroBitEvent);\n  void onGestureChanged(MicroBitEvent);\n\n  void updateGesture(void);\n  void resetGesture(void);\n\n  int normalizeCompassHeading(int heading);\n  int convertToTilt(float radians);\n\n  void composeDefaultData(uint8_t *buff);\n  void composeTxBuffer01(void);\n  void composeTxBuffer02(void);\n  void composeTxBuffer03(void);\n\n  void displayFriendlyName();\n\n  // microbit runtime instance\n  MicroBit &uBit;\n\n  // Handles to access each characteristic when they are held by Soft Device.\n  GattAttribute::Handle_t txCharacteristicHandle;\n  GattAttribute::Handle_t rxCharacteristicHandle;\n\n  GattCharacteristic *eventChar;\n  GattCharacteristic *ioChar;\n  GattCharacteristic *analogInChar;\n  GattCharacteristic *sensorsChar;\n  GattCharacteristic *sharedDataChar;\n\n  GattAttribute::Handle_t eventCharHandle;\n  GattAttribute::Handle_t ioCharHandle;\n  GattAttribute::Handle_t sensorsCharHandle;\n  GattAttribute::Handle_t sharedDataCharHandle;\n\n  enum ScratchBLECommand\n  {\n    CMD_PIN_CONFIG = 0x80,\n    CMD_DISPLAY_TEXT = 0x81,\n    CMD_DISPLAY_LED = 0x82,\n    CMD_PROTOCOL = 0x90,\n    CMD_PIN = 0x91,\n    CMD_SHARED_DATA = 0x92,\n    CMD_LIGHT_SENSING = 0x93\n  };\n\n  enum MBitMorePinCommand\n  {\n    SET_OUTPUT = 0x01,\n    SET_PWM = 0x02,\n    SET_SERVO = 0x03,\n    SET_PULL = 0x04,\n    SET_EVENT = 0x05,\n    SET_TOUCH = 0x06,\n  };\n\n  enum MBitMorePinMode\n  {\n    PullNone = 0,\n    PullUp = 1,\n    PullDown = 2,\n  };\n\n  enum MBitMoreDataFormat\n  {\n    MIX_01 = 0x01,\n    MIX_02 = 0x02,\n    MIX_03 = 0x03,\n    SHARED_DATA = 0x11,\n    EVENT = 0x12,\n  };\n\n  enum MBitMorePinEventType\n  {\n    NONE = 0,\n    ON_EDGE = 1,\n    ON_PULSE = 2,\n    ON_TOUCH = 3\n  };\n};\n\n#endif\n","README.md":"# pxt-mbit-more\n\nEnhanced Scratch3 micro:bit extension. (beta)\n \n## Usage\n\n[Scratch Microbit More â€“ Yengawa Lab](https://lab.yengawa.com/project/scratch-microbit-more/)\n\n\n## Supported targets\n\n* for PXT/microbit\n(The metadata above is needed for package search.)\n\n","enums.d.ts":"// Auto-generated. Do not edit.\n\n\n    /**\n     * Voltage of the power supply in [mV]\n     */\n\n    declare const enum ScratchBLECommand\n    {\n    CMD_PIN_CONFIG = 0x80,\n    CMD_DISPLAY_TEXT = 0x81,\n    CMD_DISPLAY_LED = 0x82,\n    CMD_PROTOCOL = 0x90,\n    CMD_PIN = 0x91,\n    CMD_SHARED_DATA = 0x92,\n    CMD_LIGHT_SENSING = 0x93,\n    }\n\n\n    declare const enum MBitMorePinCommand\n    {\n    SET_OUTPUT = 0x01,\n    SET_PWM = 0x02,\n    SET_SERVO = 0x03,\n    SET_PULL = 0x04,\n    SET_EVENT = 0x05,\n    SET_TOUCH = 0x06,\n    }\n\n\n    declare const enum MBitMorePinMode\n    {\n    PullNone = 0,\n    PullUp = 1,\n    PullDown = 2,\n    }\n\n\n    declare const enum MBitMoreDataFormat\n    {\n    MIX_01 = 0x01,\n    MIX_02 = 0x02,\n    MIX_03 = 0x03,\n    SHARED_DATA = 0x11,\n    EVENT = 0x12,\n    }\n\n\n    declare const enum MBitMorePinEventType\n    {\n    NONE = 0,\n    ON_EDGE = 1,\n    ON_PULSE = 2,\n    ON_TOUCH = 3,\n    }\n\n\n    declare const enum SharedDataIndex {\n    //% block=\"data0\"\n    DATA0 = 0,\n    //% block=\"data1\"\n    DATA1 = 1,\n    //% block=\"data2\"\n    DATA2 = 2,\n    //% block=\"data3\"\n    DATA3 = 3,\n    }\ndeclare namespace MbitMore {\n}\n\n// Auto-generated. Do not edit. Really.\n","extension.cpp":"#include \"pxt.h\"\n#include \"MbitMoreService.h\"\n\n#define UPDATE_PERIOD 11\n#define NOTIFY_PERIOD 101\n\nenum SharedDataIndex {\n    //% block=\"data0\"\n    DATA0 = 0,\n    //% block=\"data1\"\n    DATA1 = 1,\n    //% block=\"data2\"\n    DATA2 = 2,\n    //% block=\"data3\"\n    DATA3 = 3,\n};\n\n//% color=#FF9900 weight=95 icon=\"\\uf1b0\"\nnamespace MbitMore {\n    MbitMoreService* _pService = NULL;\n\n    void update() {\n        while (NULL != _pService) {\n            _pService->update();\n            fiber_sleep(UPDATE_PERIOD);\n        }\n    }\n\n    void notifyScratch() {\n        while (NULL != _pService) {\n            // notyfy data to Scratch\n            _pService->notify();\n            fiber_sleep(NOTIFY_PERIOD);\n        }\n    }\n\n    /**\n    * Starts a Scratch extension service.\n    */\n    //%\n    void startMbitMoreService() {\n        if (NULL != _pService) return;\n\n        _pService = new MbitMoreService(uBit);\n        create_fiber(update);\n        create_fiber(notifyScratch);\n    }\n\n    /**\n    * Set shared data value.\n    */\n    //%\n    void setMbitMoreSharedData(SharedDataIndex index, int value) {\n        if (NULL == _pService) return;\n\n        _pService->setSharedData((int)index, value);\n    }\n\n    /**\n     * Get shared data value. \n     */\n    //%\n    int getMbitMoreSharedData(SharedDataIndex index) {\n        if (NULL == _pService) return 0;\n\n        return _pService->getSharedData((int)index);\n    }    \n}\n","extension.ts":"\nnamespace MbitMore {\n    let sharedData: number[] = [0, 0, 0, 0];\n\n    /**\n    * Starts BLE services for Scratch Microbit-More extension.\n    */\n    //% blockId=MbitMore_startMbitMoreService block=\"start Microbit-More service\"\n    //% shim=MbitMore::startMbitMoreService\n    export function startService():void {\n        console.log(\"Microbit-More started\");\n    }\n\n    /**\n     * Set value of the shared data.\n     * @param index - Index of shared data.\n     * @param value - New value of shared data.\n     */\n    //% blockId=MbitMore_setMbitMoreSharedData block=\"set shared %index to %value\"\n    //% shim=MbitMore::setMbitMoreSharedData\n    export function setSharedData(index: SharedDataIndex, value: number):void {\n        sharedData[index] = value;\n    }\n\n    /**\n     * Get value of the shared data.\n     */\n    //% blockId=MbitMore_getMbitMoreSharedData block=\"value of shared %index\"\n    //% shim=MbitMore::getMbitMoreSharedData\n    export function getSharedData(index: SharedDataIndex):number {\n        return sharedData[index];\n    }\n}","pxt.json":"{\n    \"name\": \"pxt-scratch-microbit-more\",\n    \"version\": \"0.5.0\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"bluetooth\": \"*\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"enums.d.ts\",\n        \"shims.d.ts\",\n        \"extension.ts\",\n        \"extension.cpp\",\n        \"MbitMoreService.h\",\n        \"MbitMoreService.cpp\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"public\": false,\n    \"targetVersions\": {\n        \"branch\": \"v3.0.20\",\n        \"tag\": \"v3.0.20\",\n        \"commits\": \"https://github.com/microsoft/pxt-microbit/commits/bbb11c936a7fe25f47780c8cc120196c17bc47f6\",\n        \"target\": \"3.0.20\",\n        \"pxt\": \"6.0.19\"\n    },\n    \"yotta\": {\n        \"dependencies\": {\n            \"microbit\": \"yokobond/microbit#mbit-more\"\n        },\n        \"config\": {\n            \"microbit-dal\": {\n                \"bluetooth\": {\n                    \"enabled\": 1,\n                    \"pairing_mode\": 1,\n                    \"private_addressing\": 0,\n                    \"open\": 1,\n                    \"whitelist\": 1,\n                    \"advertising_timeout\": 0,\n                    \"tx_power\": 0,\n                    \"dfu_service\": 0,\n                    \"event_service\": 0,\n                    \"device_info_service\": 0,\n                    \"security_level\": \"SECURITY_MODE_ENCRYPTION_NO_MITM\"\n                },\n                \"gatt_table_size\": \"0x340\"\n            }\n        }\n    }\n}\n","shims.d.ts":"// Auto-generated. Do not edit.\n\n\n\n    //% color=#FF9900 weight=95 icon=\"\\uf1b0\"\ndeclare namespace MbitMore {\n\n    /**\n     * Starts a Scratch extension service.\n     */\n    //% shim=MbitMore::startMbitMoreService\n    function startMbitMoreService(): void;\n\n    /**\n     * Set shared data value.\n     */\n    //% shim=MbitMore::setMbitMoreSharedData\n    function setMbitMoreSharedData(index: SharedDataIndex, value: int32): void;\n\n    /**\n     * Get shared data value. \n     */\n    //% shim=MbitMore::getMbitMoreSharedData\n    function getMbitMoreSharedData(index: SharedDataIndex): int32;\n}\n\n// Auto-generated. Do not edit. Really.\n","test.ts":"// tests go here; this will not be compiled when this package is used as a library\n\nMbitMore.startMbitMoreService();\n"}